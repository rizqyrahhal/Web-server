/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   responsePart.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rarahhal <rarahhal@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/06/17 15:35:46 by rarahhal          #+#    #+#             */
/*   Updated: 2023/07/14 16:20:02 by rarahhal         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/responsePart.hpp"


size_t Response::_matchedLocationPosition;


Response::Response() {

    fillMimeTypes(_mimeTypes); // this data move to initial it in the beginig of programe one time to evit time delia in any response {!!!!!!!}
}

ResponseReturned Response::CreatResponse(server server, request request) {

        /* this data between this tow comment need to adding by parser */
        // parsing of config file need more check about the existing and permetion of any files or folder set inside its ...
        // std::map<int, std::string> map_err_page;
        
        // server.locations[0].index = "./www/app/html/index.html"; // need to addd in parssing !!!!


        // i need specefication about index file



        /* this is the second comment : END OF COMMENT */

            // for (size_t i = 0; i < server.locations.size(); i++)
            // {
            //     std::cout << "locations.name[" << i << "] name: " << server.locations[i].root << std::endl;
            // }
            // std::cout << "URL: " << request.url << std::endl;
        Response response;
        try
        {
            _matchedLocation = response.GetMatchedLocationRequestUrl(server.locations, request.url);
            #ifdef DEBUG
                std::cout << "_matchedLocationPosition: " << _matchedLocationPosition << "\n_matchedLocation: " << _matchedLocation << std::endl;
                std::cout << "_matchedLocation.root: " << server.locations[_matchedLocationPosition].root << std::endl;
            #endif
            Response::IsMethodAllowedInLocation(server.locations[_matchedLocationPosition].allow_methods, request.method, response);
            Response::IsLocationHaveRedirection(server.locations[_matchedLocationPosition], response);

            /* Check Which Requested Method */
            if (request.method == "GET")
                response.GetMethod(server, request, bodyfile, isfile);
            else if (request.method == "DELETE")
                response.DeleteMethod(server, request);
            else if (request.method == "POST")
                    response.PostMethod(server, request);
            else
                std::cout << "IF SHOWING THIS LINE IT IS A PROBLEME BEFORE WORKING ON THE REQUESTED METHOD !!!!!!!!!\n";
        }
        catch(int statuscode) {
                std::string *res = new std::string(response.ResponseGeneratedFromStatusCode(statuscode, server, request, bodyfile, isfile));
                ResponseReturned resp;
                resp.setHeaders(*res);
                if (!bodyfile.empty()) {
                    resp.setBody(bodyfile);
                    resp.setIsFile(isfile);
                }
                if (!isfile && statuscode == 200)
                    setHeader("Content-Length", std::to_string(bodyfile.size()));
                return (resp);
        }
        catch(std::string str) // Cgi
        {
            std::string *res = new std::string(str);
            /* here check and add the needed status to the response generated by cgi */
            ResponseReturned resp;
            resp.setBody(*res);
            // std::cout << "Dody Cgi SIZE : " << resp.getBody().size() << std::endl;
            return (resp);
        }
    
    /* here just to evet the return value error */
    ResponseReturned resp;
    return (resp);
}

/* rest small choise not handling in headers !!!!!!!!!!!!! */
std::string Response::ResponseGeneratedFromStatusCode(int statuscode, server server, request request, std::string &bodyfile, bool &isfile) {
    (void)request;
    /* Start line element */
    setVersion("HTTP/1.1");
	setStatusCode(statuscode);
	setStatusMessage(getReason(statuscode));

    /* set default headers */
	// setHeader("Date: ", generateDate());
	setHeader("Connection", "close"); // from map headers (request data)   request.getHeaderValue(std::string key)  <---- this function global to get any header from map headers in the request (key in this case = "Conection")

    if (statuscode != 200 && statuscode != 201 && statuscode != 204)
    {
		std::string err_page = SearchAboutErrorPageFormTowPlaces(statuscode, server.map_err_page, server.locations[_matchedLocationPosition].map_err_page); //the last map not implemented by parser
        if (!err_page.empty()) {
            setHeader("Content-Length", std::to_string(calculeBodySize(err_page)));
		    bodyfile = err_page;
            isfile = true;
        }
        else{
            bodyfile = GenerateErrorPage(statuscode, getReason(statuscode));
            setHeader("Content-Length", std::to_string(bodyfile.size()));
            isfile = false;
        }
        setHeader("Content-Type", "text/html");
    }

    /* adding headers */
    // if (statuscode != 201 && statuscode != 204 && statuscode != 200)
    // setHeader("Content-Length", std::to_string(getBodySize()));

	// GENERATE_THE_FINALE_RESPONSE();
    std::string res = generateResponse();

    return res;
}


void Response::cgi(server server, request request) {
	(void)server;
	Cgi cgi;

	cgi.fillEnvp(request, server, _requestedSource);

		size_t uy = request.map_request.size();
		std::cout << "~~~~~~~~~~~~~~~~~~~~ Request Headers ~~~~~~~~~~~~~~~~~~~~\nHEADER_SIZE: "<< uy << std::endl;
		for (std::map<std::string, std::string>::iterator it = request.map_request.begin(); it != request.map_request.end(); ++it) {
			std::cout << it->first << "=" << it->second << std::endl << uy << std::endl;
			uy--;
		}

		std::cout << "****888888****: " << _requestedSource << std::endl;
		char* argv[] = {
        // (char*)"./tools/cgi-bin/php-cgi.exe",
        (char*)"./cgi_tester",
        (char*)_requestedSource.c_str(),
        nullptr
        };
		char* envp[] = {
		(char*)"SERVER_PROTOCOL=HTTP/1.1",
		(char*)"REQUEST_METHOD=GET",
		(char*)"PATH_INFO=./tools/cgi-scripts/php/upload_simple.php",
		(char*)"REDIRECT_STATUS=",
        (char*)"SERVER_PORT=8080",
		(char*)"AUTH_TYPE",
		(char*)"CONTENT_LENGTH",
        (char*)"CONTENT_TYPE",
		(char*)"GATEWAY_INTERFACE",
		(char*)"PATH_TRANSLATED",
        (char*)"QUERY_STRING",
		(char*)"REMOTE_ADDR",
        (char*)"REMOTE_HOST",
		(char*)"REMOTE_IDENT",
        (char*)"REMOTE_USER",
        (char*)"SCRIPT_NAME",
		(char*)"SERVER_NAME",
        (char*)"SERVER_SOFTWARE",
		(char*)"Accept-Encoding=gzip, deflate, br",
		(char*)"Accept-Language=en-US,en;q=0.9",
		(char*)"Cache-Control=max-age=0",
		(char*)"Connection=keep-alive",
		(char*)"Cookie=_ga=GA1.1.1276071924.1689035207; _ga_BVS1XM9LYJ=GS1.1.1689035207.1.1.1689035438.8.0.0; __gads=ID=d57167e481e2e578-223635ec3ae00050:T=1689035229:RT=1689036300:S=ALNI_MZeZpUb6CJn5WXJvh1UhjY-QILGAw; __gpi=UID=00000c65db6194a3:T=1689035229:RT=1689036300:S=ALNI_MZg5-InE8f8kHbBfHhC8yHKkIfFeg; PHPSESSID=a6dd5c948bdbfebf6dc11f830e45afb3",
		(char*)"Host=localhost:8080",
		(char*)"Sec-Fetch-Dest=document",
		(char*)"Sec-Fetch-Mode=navigate",
		(char*)"Sec-Fetch-Site=none",
		(char*)"Sec-Fetch-User=?1",
		(char*)"Upgrade-Insecure-Requests=1",
		(char*)"User-Agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
		(char*)"sec-ch-ua='Not.A/Brand';v='8', 'Chromium';v='114', 'Google Chrome';v='114'",
		(char*)"sec-ch-ua-mobile=?0",
		(char*)"sec-ch-ua-platform='macOS'",
		(char*)"Accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
		// (char*)"",
		// (char*)"",
		nullptr
		};
		cgi.execut("./cgi_tester", argv, envp, _requestedSource);
}

Response::~Response() {

}

/* the WORK rest :
    cgi handlig of the env
    cgi flow and detecting the status code
    the index.php and index.by
    the read and set file in the case uplod

    make more test in the matched location and the searching about requested source 
*/