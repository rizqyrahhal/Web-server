/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   responsePart.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rarahhal <rarahhal@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/06/17 15:35:46 by rarahhal          #+#    #+#             */
/*   Updated: 2023/07/13 04:20:21 by rarahhal         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/responsePart.hpp"


size_t Response::_matchedLocationPosition;


Response::Response() {

    fillMimeTypes(_mimeTypes); // this data move to initial it in the beginig of programe one time to evit time delia in any response {!!!!!!!}
}

ResponseReturned Response::CreatResponse(server server, request request) {

        /* this data between this tow comment need to adding by parser */
        // parsing of config file need more check about the existing and permetion of any files or folder set inside its ...
        // std::map<int, std::string> map_err_page;
        
        // server.locations[0].index = "./www/app/html/index.html"; // need to addd in parssing !!!!


        // i need specefication about index file



        /* this is the second comment : END OF COMMENT */

            // for (size_t i = 0; i < server.locations.size(); i++)
            // {
            //     std::cout << "locations.name[" << i << "] name: " << server.locations[i].root << std::endl;
            // }
            // std::cout << "URL: " << request.url << std::endl;
        Response response;
        try
        {

            _matchedLocation = response.GetMatchedLocationRequestUrl(server.locations, request.url);
            #ifdef DEBUG
                std::cout << "_matchedLocationPosition: " << _matchedLocationPosition << "\n_matchedLocation: " << _matchedLocation << std::endl;
                std::cout << "_matchedLocation.root: " << server.locations[_matchedLocationPosition].root << std::endl;
            #endif
            Response::IsMethodAllowedInLocation(server.locations[_matchedLocationPosition].allow_methods, request.method, response);
            Response::IsLocationHaveRedirection(server.locations[_matchedLocationPosition], response);

            /* Check Which Requested Method */
            if (request.method == "GET")
                response.GetMethod(server, request, bodyfile, isfile);
            else if (request.method == "DELETE")
                response.DeleteMethod(server, request);
            else if (request.method == "POST")
                    response.PostMethod(server, request);
            else
                std::cout << "IF SHOWING THIS LINE IT IS A PROBLEME BEFORE WORKING ON THE REQUESTED METHOD !!!!!!!!!\n";
        }
        catch(int statuscode) {
                std::string *res = new std::string(response.ResponseGeneratedFromStatusCode(statuscode, server, request, bodyfile, isfile));
                ResponseReturned resp;
                resp.setHeaders(*res);
                if (!bodyfile.empty()) {
                    resp.setBody(bodyfile);
                    resp.setIsFile(isfile);
                }
                if (!isfile && statuscode == 200)
                    setHeader("Content-Length", std::to_string(bodyfile.size()));
                return (resp);
        }
        catch(std::string str) // Cgi
        {
            std::string *res = new std::string(str);
            /* here check and add the needed status to the response generated by cgi */
            ResponseReturned resp;
            resp.setHeaders(*res);
            return (resp);
        }
    
    /* here just to evet the return value error */
    ResponseReturned resp;
    return (resp);
}

/* rest small choise not handling in headers !!!!!!!!!!!!! */
std::string Response::ResponseGeneratedFromStatusCode(int statuscode, server server, request request, std::string &bodyfile, bool &isfile) {
	// request request;
	// Server	server;

    (void)request;
    /* Start line element */
    setVersion("HTTP/1.1");
	setStatusCode(statuscode);
	setStatusMessage(getReason(statuscode));

    /* set default headers */
	// setHeader("Date: ", generateDate());
	setHeader("Connection", "close"); // from map headers (request data)   request.getHeaderValue(std::string key)  <---- this function global to get any header from map headers in the request (key in this case = "Conection")

    /* HERE response have rederect message not have any body or something like this her is the probleme*/
	/* search about error page in map_error page */

    if (statuscode != 200 && statuscode != 201 && statuscode != 204)   // change this with categore redirection-error
    {
		// std::string err_page = SearchAboutErrorPage(statuscode, server.map_err_page);
		std::string err_page = SearchAboutErrorPageFormTowPlaces(statuscode, server.map_err_page, server.locations[_matchedLocationPosition].map_err_page); //the last map not implemented by parser
        if (!err_page.empty()) {
            setHeader("Content-Length", std::to_string(calculeBodySize(err_page)));
		    bodyfile = err_page;
            isfile = true;
        	// setBody(ReadErrorPage(err_page)); // remove after make the function to read by chunck
        }
        else{
            bodyfile = GenerateErrorPage(statuscode, getReason(statuscode));
            setHeader("Content-Length", std::to_string(bodyfile.size()));
            isfile = false;
            // setBody(GenerateErrorPage(statuscode, getReason(statuscode))); // remove after make the function to read by chunck
        }
        setHeader("Content-Type", "text/html"); //generateContentType(), that is oky for new becous the error type in all time html and the other way detecte and assigne in the same place
    }

    /* adding headers */
    // if (statuscode != 201 && statuscode != 204 && statuscode != 200)
    // setHeader("Content-Length", std::to_string(getBodySize()));

	// GENERATE_THE_FINALE_RESPONSE();
    std::string res = generateResponse();

    return res;
}

Response::~Response() {

}

/* the WORK rest :
    cgi handlig of the env
    cgi flow and detecting the status code
    the index.php and index.by
    function to read by size

    make more test in the matched location and the searching about requested source 
*/


